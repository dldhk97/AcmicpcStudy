//#11057
//
//제목
//오르막 수
//
//문제
//
//오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다.이때, 인접한 수가 같아도 오름차순으로 친다.
//
//예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.
//
//수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오.수는 0으로 시작할 수 있다.
//입력
//
//첫째 줄에 N(1 ≤ N ≤ 1, 000)이 주어진다.
//출력
//
//첫째 줄에 길이가 N인 오르막 수의 개수를 10, 007로 나눈 나머지를 출력한다.

#include <iostream>

using namespace std;

//이것도 마찬가지로 끝자리에 영향을 받는다.
//앞에서 푼 문제와 비슷한 유형인것 같다.
//2차원 배열로, arr[i][j]를 두고, i는 숫자의 자리 수, j는 숫자의 끝 자리 수로 두고 하였다.
//이번 문제의 키포인트는 마지막 숫자보다 작은 수는 이후에 배치될 수 없다는 점이다.
//마지막이 7이면 0~6까지는 7 다음에 배치될 수 없다는 것.
//따라서 0은 000이 아니면 배치될 수 없다.
//이러한 특성에서 배치하려는 숫자가 커질수록, 9에 가까워 질수록 더 많은 곳에 배치될 수 있다는 점을 알 수 있다.
//ex) N=3일때, 33 이후에는 0,1,2는 들어갈 수 없지만, 3 이후의 수는 배치될 수 있다.
//이번 점화식은 N=3까지 해보다가 규칙 발견해서 찾았다...
//마지막 숫자가 0이면 이후에 0~9까지 배치 가능,
//마지막 숫자가 1이면 이후에 1~9까지 배치 가능,
//...
//마지막 숫자가 9이면 이후에 9만 배치 가능.
//즉, 점화식은 이렇게 된다.
//arr[i][j] = arr[i - 1][0] + arr[i - 1][1] + arr[i - 1][2] + ... + arr[i - 1][j]
//예를들어, i=3이고, j=3인 경우는 이렇게 나온다.
//arr[3][3] = arr[2][0] + arr[2][1] + arr[2][2] + arr[2][3]

int arr[1001][10];
const int DIVIDE = 10007;

void init()
{
	for (int j = 0; j < 10; j++)
	{
		arr[1][j] = 1;
	}
}

void calc(int n)
{
	for (int i = 1; i <= n; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			for (int k = 0; k <= j; k++)
			{
				arr[i][j] = (arr[i][j] + arr[i - 1][k]) % DIVIDE;
			}
		}
	}
}

int getSum(int n)
{
	int sum = 0;

	for (int j = 0; j < 10; j++)
	{
		sum = (sum + arr[n][j]) % DIVIDE;
	}

	return sum;
}

int main()
{
	int input;

	init();

	cin >> input;

	calc(input);

	cout << getSum(input) << '\n';

	return 0;
}