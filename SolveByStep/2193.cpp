//#2193
//
//제목
//이친수
//
//문제
//
//0과 1로만 이루어진 수를 이진수라 한다.이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다.이친수는 다음의 성질을 만족한다.
//
//이친수는 0으로 시작하지 않는다.
//이친수에서는 1이 두 번 연속으로 나타나지 않는다.즉, 11을 부분 문자열로 갖지 않는다.
//
//예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다.하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.
//
//N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.
//입력
//
//첫째 줄에 N이 주어진다.
//출력
//
//첫째 줄에 N자리 이친수의 개수를 출력한다.

//처음에는 N=8까지 해보면서 규칙을 찾았다.
//f(n) = f(n-1) + f(n-2) 이라는 점화식을 구했다.
//아래 코드는 해당 점화식을 바탕으로 짜보았다.
//백준에 돌려보니까 잘돌아갔다.
//그런데 왜 f(n-1) + f(n-2)라는 점화식이 나오는지는 모르겠다.
//그래서 이중배열을 사용한 두번째 코드를 짜보았다.

//#include <iostream>
//
//using namespace std;
//
//long long dp[91] = { 0, 1, 1 };
//
//long long solution(long long n)
//{
//	if (dp[n])
//		return dp[n];
//
//	dp[n] = solution(n - 1) + solution(n - 2);
//	return dp[n];
//}
//
//int main()
//{
//	int N;
//	cin >> N;
//	cout << solution(N) << '\n';
//	return 0;
//}

//이중배열을 사용한 코드는 아래와 같다.
//두번째 인덱스에는 끝나는 숫자를 의미부여했다. 
//0이면 0으로 끝나는 수의 개수, 1이면 1로 끝나는 수의 개수를 의미한다.
//새로 찾은 점화식은 위에서 짠 코드와는 달랐다.

//if(j == 0) dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
//else if(j == 0) dp[i][1] = dp[i - 1][0];
//이렇게 되는데, N자리 수 중 0으로 끝나는 수의 개수는 
//N-1자리 수 중 0으로 끝나는 수와, 1로 끝나는 수의 합으로 나타내어진다.

//왜냐하면 끝나는 수가 0이면 그 다음에는 0이 들어와도 되고, 1도 들어와도 된다.
//반면 끝나는 수가 1이면 무조건 0이 들어와야한다.
//이 규칙 덕분에, N자리 수 중 1로 끝나는 수는 N-1자리 수 중 0으로 끝나는 수에 의해서만 만들어지고,
//N자리 수 중 0으로 끝나는 수는 N-1자리 수중 0으로 끝나는 수와 1로 끝나는 수 모두에 의해 만들어진다.
//때문에 이러한 점화식이 만들어진다.

#include <iostream>

using namespace std;

//dp[i][j]는 i는 자리수를 의미하고, j는 마지막 수가 무엇인지를 의미한다.
//즉, dp[6][1]이면 6자리 수 중 끝이 1로끝나는 수의 개수를 의미한다.
long long dp[91][2];

void init()
{
	dp[1][0] = 0;
	dp[1][1] = 1;

	dp[2][0] = 1;
	dp[2][1] = 0;
}

void solution(int n)
{
	for (int i = 3; i <= n; i++)
	{
		dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
		dp[i][1] = dp[i - 1][0];
	}
}

long long getSum(int n)
{
	return dp[n][0] + dp[n][1];
}

int main()
{
	int N;
	init();

	cin >> N;
	solution(N);
	cout << getSum(N) << '\n';
	return 0;
}